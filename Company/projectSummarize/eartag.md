# 智能耳标对接总结 22-12-12 - 23-01-11

## 需求描述

```
但是这里的需求并不是和上面的一模一样。而是第三方给我们的账户下分配设备。用户再由请求我们的云端来添加和使用设备。
```

## 我理解的需求

```
最开始以为时做一个类似七牛云的监控设备对接，包含云端后台管理系统，云端开放接口，用户端后台管理系统，用户端接口。
管理端通过mac地址向第三方添加设备。（其实并不是）
添加时通过设备的mac地址添加。本质上是通过云端的接口，在我们注册的账户下添加，然后使用。
但是其实并不是，结果是我们这点存。相当于，我们的用户，是第三方不知道的子用户。
```

## 关于设计

### 云端数据库

```
id自增，加上user_id字段，加上status字段，加上create_time,update_time,其他的保存第三方数据
保存第三方的的设备数据，但是不保存第三方的日志信息，请求日志信息时，仍然时读取第三方的信息。
```

### 云端管理系统设计

```
添加：先请求第三方,第三方返回正确的信息，再写入到云端数据库中。
修改：也是先请求第三方，修改成功之后，更新数据库。
删除：只提供软删除，第三方没提供删除接口
数据同步：比较数据库和第三方的所有数据，把数据库和第三方的差集写入，遍历数据库和第三方的交集并更新数据库
```

### 云端开放接口设计

```
以服务的方式，封装所有接口。（请求云端时，会进行身份校验）
硬件信息的CRUD都是对云端数据的操作
添加：用户添加设备时，对比云端数据库中是否有该设备。
    如果没有就同步第三方数据，如果还是并再次查询。如果还是不存在，则返回不存在。
```

### 本地数据库

```
只保存添加的耳标设备，以供下单时，用户的使用。
请求云端添加接口成功之后，才添加
```

### 本地请求云端接口封装

```
封装了server层，再封装了api层，controller通过api调用。隐藏了细节。
请求统一封装。
```

## 关于redis锁

### 云端redis的使用

```
（项目最开始的设计就不用说了。缓存了请求用户的数据）
空key：因为以为是通过mac地址请求第三方添加。（文档里确实是这么写的），然后加了个空key，如果第三方返回该mac不存在，则缓存该mac。
setNx Lock：因为用户添加设备是，请求云端的数据库。云端的数据库并不一定和第三方的数据一致。
            设计及成了，用户查询我们数据库，发现该设备不存在时，调用同步的接口，因为同步的接口，会涉及到第三方的调用（指网络I/O比较耗时），以及要更新数据库。如果太频繁调用，会给数据库造成较大的压力。所以限制了非管理员用户在n分钟之内不能调用同步接口。
```

### 管理端redis使用

```
需求描述：用户下单时，可以选择一个耳标，并创建订单。订单有失效时间。
代替mysql的锁：用户下单时带有耳标时，先查询该耳标是否可用。可用则setnx缓存，再expire TTL = 订单过期的时间 + 30s。
用户支付时： 因为订单有过期时间，而缓存的时间比过期时间长一点。而且订单过期了，也不能支付。（原来可以，被我限制了）
用户支付成功后：expire这个key
```

## 总结

需求方面：

- 需求一定要明确！
- 需求一定要明确！！
- 需求一定要明确！！！
- 宁愿前期多花点时间在需求上，也不要后面来改代码，改设计，该逻辑。
- 第三方文档一定要喊写清楚。如果文档写的不清楚，就不对接这个需求。
  
设计方面：

- 先明白需求之后，再说！
- 数据库的字段设计尽量合理，多一点冗余字段也行，可以减少I/O
- 合理运用redis
- 尽量设计成服务的形式。封装请求和逻辑，控制器只管调用。也方便更改
  
开发方面：
  
- 先弄懂了需求再来！
- 尽快开发出来需求。
  
好的地方：

- 封装了请求与接口，方便使用
  
不足的地方：

- 需求还没开始整明白，就是开始写到代码了
- 第三方日志返回时间正序，前端要求正序，想的是兼容第三方，而不是叫他们改代码。（×避免给别人当🐕）
- 日志本来一天很多条，我还问了要不要整理，前端说一天返回一条。整理之后，又说数据对不上。（🤷‍♂️）
- 效率不高
- 不能随时都保持头脑清醒
- 不能随时保持理智
- 本末倒置。项目就是要先快速写出来，优化是后面的事！
  
最后想说：ucdo 想写什么项目就去写把，想用什么语言，想学什么框架，想学什么技术，想用什么组件，就去用，不用担心。没有人可以定义你自己。除了自己。不要给自己贴只能干PHP开发的标签！
